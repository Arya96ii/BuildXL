// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Diagnostics.ContractsLight;
using System.Threading.Tasks;
using BuildXL.Cache.ContentStore.Distributed.Blob;
using BuildXL.Cache.ContentStore.Distributed.MetadataService;
using BuildXL.Cache.ContentStore.Distributed.NuCache;
using BuildXL.Cache.ContentStore.Distributed.NuCache.ClusterStateManagement;
using BuildXL.Cache.ContentStore.Distributed.Stores;
using BuildXL.Cache.ContentStore.Distributed.Utilities;
using BuildXL.Cache.ContentStore.FileSystem;
using BuildXL.Cache.ContentStore.Grpc;
using BuildXL.Cache.ContentStore.Interfaces.Results;
using BuildXL.Cache.ContentStore.Interfaces.Secrets;
using BuildXL.Cache.ContentStore.Interfaces.Stores;
using BuildXL.Cache.ContentStore.Interfaces.Time;
using BuildXL.Cache.ContentStore.Service.Grpc;
using BuildXL.Cache.ContentStore.Stores;
using BuildXL.Cache.ContentStore.Tracing.Internal;
using BuildXL.Cache.Host.Configuration;
using BuildXL.Cache.MemoizationStore.Interfaces.Caches;
using BuildXL.Cache.MemoizationStore.Interfaces.Stores;
using BuildXL.Cache.MemoizationStore.Sessions;
using BuildXL.Utilities.Core;
using ProtoBuf.Grpc.Client;
using AbsolutePath = BuildXL.Cache.ContentStore.Interfaces.FileSystem.AbsolutePath;

#nullable enable

namespace BuildXL.Cache.ContentStore.Distributed.Ephemeral;

/// <nodoc />
public static class EphemeralCacheFactory
{
    /// <nodoc />
    public abstract record Configuration
    {
        /// <summary>
        /// Location on drive where cache is located
        /// </summary>
        public required AbsolutePath RootPath { get; init; }

        /// <summary>
        /// Hostname and port that allows other machines to communicate with this machine
        /// </summary>
        public required MachineLocation Location { get; init; } = MachineLocation.Create(Environment.MachineName, GrpcConstants.DefaultGrpcPort);

        /// <summary>
        /// Hostname and port of the leader machine
        /// </summary>
        public required MachineLocation Leader { get; init; }
    }

    /// <summary>
    /// This configuration allows us to create a cache that is shared by all builds in the datacenter. This means that
    /// content generated by any of the concurrently running builds will be available to all other concurrently running
    /// builds.
    /// </summary>
    public sealed record DatacenterWideCacheConfiguration : Configuration
    {
        /// <summary>
        /// Credentials for the storage account we use to store metadata about the cluster.
        /// </summary>
        public required AzureStorageCredentials StorageCredentials { get; init; }
    };

    /// <summary>
    /// This configuration allows us to create a cache that is shared only by the builders collaborating on a single
    /// build.
    /// </summary>
    public sealed record BuildWideCacheConfiguration : Configuration
    {
    };

    /// <summary>
    /// Creates a P2P cache.
    /// </summary>
    public static async Task<IFullCache> CreateAsync(OperationContext context, Configuration configuration, IFullCache persistentCache)
    {
        return (await CreateInternalAsync(context, configuration, persistentCache)).Cache;
    }

    internal static Task<CreateResult> CreateInternalAsync(OperationContext context, Configuration configuration, IFullCache persistentCache)
    {
        return configuration switch
        {
            DatacenterWideCacheConfiguration datacenterWideCacheConfiguration => CreateDatacenterWideCacheAsync(context, datacenterWideCacheConfiguration, persistentCache),
            BuildWideCacheConfiguration buildWideCacheConfiguration => CreateBuildWideCacheAsync(context, buildWideCacheConfiguration, persistentCache),
            _ => throw new NotSupportedException($"Cache type {configuration.GetType().Name} is not supported.")
        };
    }

    internal static Task<CreateResult> CreateDatacenterWideCacheAsync(
        OperationContext context,
        DatacenterWideCacheConfiguration configuration,
        IFullCache persistentCache)
    {
        var blobClusterStateStorageConfiguration = new BlobClusterStateStorageConfiguration()
        {
            Storage = new BlobClusterStateStorageConfiguration.StorageSettings(configuration.StorageCredentials, ContainerName: "ephemeral", FolderName: "clusterState"),
            BlobFolderStorageConfiguration = new(),
            FileName = "clusterState.json",
            RecomputeConfiguration = new ClusterStateRecomputeConfiguration(),
        };
        var clusterStateStorage = new BlobClusterStateStorage(blobClusterStateStorageConfiguration, SystemClock.Instance);

        var masterElectionMechanism = CreateMasterElectionMechanism(configuration.Location, configuration.Leader);
        return CreateInternalAsync(
            context,
            configuration,
            masterElectionMechanism,
            clusterStateStorage,
            persistentCache,
            grpcClusterStateEndpoint: null);
    }

    internal static Task<CreateResult> CreateBuildWideCacheAsync(
        OperationContext context,
        BuildWideCacheConfiguration configuration,
        IFullCache persistentCache)
    {
        var masterElectionMechanism = CreateMasterElectionMechanism(configuration.Location, configuration.Leader);

        IGrpcServiceEndpoint? grpcClusterStateEndpoint = null;
        IClusterStateStorage clusterStateStorage;
        if (masterElectionMechanism.Role == Role.Master)
        {
            clusterStateStorage = new InMemoryClusterStateStorage();
            var service = new GrpcClusterStateStorageService(clusterStateStorage);
            grpcClusterStateEndpoint = new ProtobufNetGrpcServiceEndpoint<IGrpcClusterStateStorage, GrpcClusterStateStorageService>(nameof(GrpcClusterStateStorageService), service);
        }
        else
        {
            clusterStateStorage = new GrpcClusterStateStorageClient(
                configuration: new GrpcClusterStateStorageClient.Configuration(
                    TimeSpan.FromMinutes(1),
                    RetryPolicyConfiguration.Exponential()),
                accessor: new DelayedClientAccessor<IGrpcClusterStateStorage>(
                    async () =>
                    {
                        var connectionHandle = new ConnectionHandle(
                            context,
                            configuration.Leader,
                            GrpcConstants.DefaultGrpcPort,
                            // Allow waiting for the leader to setup for up to 30m
                            connectionTimeout: TimeSpan.FromSeconds(30));
                        await connectionHandle.StartupAsync(context).ThrowIfFailureAsync();

                        return connectionHandle.Channel.CreateGrpcService<IGrpcClusterStateStorage>(MetadataServiceSerializer.ClientFactory);
                    }
                ));
        }

        return CreateInternalAsync(
            context,
            configuration,
            masterElectionMechanism,
            clusterStateStorage,
            persistentCache,
            grpcClusterStateEndpoint);
    }

    private static IMasterElectionMechanism CreateMasterElectionMechanism(MachineLocation location, MachineLocation leader)
    {
        if (location.Equals(leader))
        {
            return new RiggedMasterElectionMechanism(location, Role.Master);
        }

        return new RiggedMasterElectionMechanism(leader, Role.Worker);
    }

    internal record CreateResult(EphemeralHost Host, IFullCache Cache);

    /// <nodoc />
    private static Task<CreateResult> CreateInternalAsync(
        OperationContext context,
        Configuration configuration,
        IMasterElectionMechanism masterElectionMechanism,
        IClusterStateStorage clusterStateStorage,
        IFullCache persistentCache,
        IGrpcServiceEndpoint? grpcClusterStateEndpoint)
    {
        var (address, port) = configuration.Location.ExtractHostInfo();
        Contract.Requires(port is not null, $"Port missing from the configured reachable DNS name: {configuration.Location}");

        var localContentTracker = new LocalContentTracker();

        var clusterStateManagerConfiguration = new ClusterStateManager.Configuration
        {
            PrimaryLocation = configuration.Location,
            UpdateInterval = TimeSpan.FromMilliseconds(100),
        };
        var distributedContentTrackerConfiguration = new DistributedContentTracker.Configuration();

        var clusterStateManager = new ClusterStateManager(clusterStateManagerConfiguration, clusterStateStorage, clock: SystemClock.Instance);

        var shardManager = new ClusterStateShardManager(clusterStateManager.ClusterState);
        var shardingScheme = new RendezvousConsistentHash<MachineId>(shardManager, id => HashCodeHelper.GetHashCode(id.Index));

        var grpcContentTrackerClientConfiguration = new GrpcContentTrackerClient.Configuration(
            TimeSpan.FromMinutes(1),
            RetryPolicyConfiguration.Exponential());

        var grpcConnectionPoolConfiguration = new ConnectionPoolConfiguration
        {
            ConnectTimeout = TimeSpan.FromSeconds(1),
            DefaultPort = GrpcConstants.DefaultGrpcPort,
            UseGrpcDotNet = true,
            GrpcDotNetOptions = new GrpcDotNetClientOptions(),
        };
        var connectionPool = new GrpcConnectionPool(grpcConnectionPoolConfiguration, context, clock: SystemClock.Instance);

        var clientAccessor = new GenericGrpcClientAccessor<IGrpcContentTracker, IContentTracker>(
            connectionPool,
            service => new GrpcContentTrackerClient(
                grpcContentTrackerClientConfiguration,
                new FixedClientAccessor<IGrpcContentTracker>(service)));

        var distributedContentTracker = new DistributedContentTracker(
            distributedContentTrackerConfiguration,
            clusterStateManager.ClusterState,
            shardingScheme,
            localContentTracker,
            clientAccessor,
            masterElectionMechanism,
            clock: SystemClock.Instance);

        var service = new GrpcContentTrackerService(localContentTracker);
        var contentTrackerEndpoint =
            new ProtobufNetGrpcServiceEndpoint<IGrpcContentTracker, GrpcContentTrackerService>(nameof(GrpcContentTrackerService), service);

        var contentStoreConfiguration = ContentStoreConfiguration.CreateWithMaxSizeQuotaMB(1000);
        var configurationModel = new ConfigurationModel(
            contentStoreConfiguration,
            ConfigurationSelection.RequireAndUseInProcessConfiguration,
            MissingConfigurationFileOption.DoNotWrite);
        var contentStoreSettings = ContentStoreSettings.DefaultSettings;
        var contentStore = new FileSystemContentStore(
            PassThroughFileSystem.Default,
            clock: SystemClock.Instance,
            configuration.RootPath / "store",
            configurationModel,
            distributedStore: null,
            settings: contentStoreSettings);
        contentStore.Store.Announcer = new FileSystemNotificationReceiver(distributedContentTracker);

        var storesByName = new Dictionary<string, IContentStore>() { { "Default", contentStore }, };
        var copyServerConfiguration = new GrpcCopyServer.Configuration();
        var copyServer = new GrpcCopyServer(context.TracingContext.Logger, storesByName, copyServerConfiguration);
        var distributedContentCopierConfiguration = new DistributedContentCopier.Configuration() { };
        var remoteFileCopier = new GrpcFileCopier(context, new GrpcFileCopierConfiguration()
        {
            UseUniversalLocations = true,
        });
        var contentCopier = new DistributedContentCopier(
            distributedContentCopierConfiguration,
            PassThroughFileSystem.Default,
            remoteFileCopier,
            // This is actually useless. We don't support proactive copies (on purpose)
            copyRequester: remoteFileCopier,
            SystemClock.Instance,
            context.TracingContext.Logger);

        var host = new EphemeralHost(
            new EphemeralCacheConfiguration
            {
                GrpcConfiguration = new GrpcCoreServerHostConfiguration(GrpcPort: port!.Value),
                Workspace = configuration.RootPath / "workspace",
            },
            PassThroughFileSystem.Default,
            localContentTracker,
            distributedContentTracker,
            clusterStateManager,
            contentTrackerEndpoint,
            copyServer,
            contentCopier,
            grpcClusterStateEndpoint
        );

        var ephemeralContentStore = new EphemeralContentStore(
            contentStore,
            persistentCache,
            host);

        var cache = new OneLevelCache(
            () => ephemeralContentStore,
            () => (IMemoizationStore)persistentCache,
            new OneLevelCacheBaseConfiguration(Guid.NewGuid(), PassContentToMemoization: false));

        return Task.FromResult(new CreateResult(Host: host, Cache: cache));
    }
}
