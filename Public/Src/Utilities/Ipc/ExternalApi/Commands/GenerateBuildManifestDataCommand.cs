// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.IO;
using BuildXL.Utilities;
using System.Diagnostics.ContractsLight;
using BuildXL.Cache.ContentStore.Hashing;
using System.Linq;
using System.Text;

namespace BuildXL.Ipc.ExternalApi.Commands
{
    /// <summary>
    /// Command corresponding to the <see cref="Client.GenerateBuildManifestFileList"/> API operation.
    /// </summary>
    public sealed class GenerateBuildManifestFileListCommand : Command<List<BuildManifestFileInfo>>
    {
        /// <summary>
        /// DropName to identify which drop the Build Manifest is being generated for.
        /// </summary>
        public string DropName { get; }

        /// <nodoc />
        public GenerateBuildManifestFileListCommand(string dropName)
        {
            DropName = dropName;
        }

        /// <inheritdoc />
        public override bool TryParseResult(string result, out List<BuildManifestFileInfo> commandResult)
        {
            commandResult = new List<BuildManifestFileInfo>();

            using (var reader = new StringReader(result)) 
            {
                var count = reader.ReadLine();
                if (!int.TryParse(count, out var numberOfFiles))
                {
                    return false;
                }

                for (int i = 0; i < numberOfFiles; i++)
                {
                    string val = reader.ReadLine();
                    if (!BuildManifestFileInfo.TryParse(val, out var buildManifestFileInfo))
                    {
                        return false;
                    }

                    commandResult.Add(buildManifestFileInfo);
                }

                return true;
            }
        }

        /// <inheritdoc />
        public override string RenderResult(List<BuildManifestFileInfo> commandResult)
        {
            Contract.Requires(commandResult != null);

            using var stringBuilderPoolInstance = Pools.StringBuilderPool.GetInstance();
            var sb = stringBuilderPoolInstance.Instance;
            sb.AppendLine($"{commandResult.Count}");

            foreach (BuildManifestFileInfo fileInfo in commandResult)
            {
                sb.AppendLine(fileInfo.ToString());
            }

            return sb.ToString();
        }

        internal override void InternalSerialize(BinaryWriter writer)
        {
            writer.Write(DropName);
        }

        internal static Command InternalDeserialize(BinaryReader reader)
        {
            return new GenerateBuildManifestFileListCommand(reader.ReadString());
        }
    }

    /// <summary>
    /// Stores Hash values and RelativePath of individual files added to drop
    /// </summary>
    public class BuildManifestFileInfo : IEquatable<BuildManifestFileInfo>
    {
        /// <nodoc/>
        public string RelativePath { get; }

        /// <nodoc/>
        public ContentHash AzureArtifactsHash { get; }

        /// <nodoc/>
        public IReadOnlyList<ContentHash> BuildManifestHashes { get; }

        /// <nodoc/>
        public BuildManifestFileInfo(
            string relativePath,
            ContentHash azureArtifactsHash,
            IReadOnlyList<ContentHash> buildManifestHashes)
        {
            Contract.Requires(!string.IsNullOrEmpty(relativePath));
            Contract.Requires(azureArtifactsHash.IsValid);
            Contract.Requires(buildManifestHashes.All(h => h.IsValid));

            RelativePath = relativePath;
            AzureArtifactsHash = azureArtifactsHash;
            BuildManifestHashes = buildManifestHashes;
        }

        /// <summary>
        /// Separator used for serialization
        /// </summary>
        public const char Separator = '|';

        /// <summary>
        /// Number of fields to be serialized within BuildManifestFileInfo
        /// </summary>
        private const int MinFieldCount = 3;

        /// <summary>
        /// String representation format: RelativePath | AzureArtifactsHash | BuildManifestHash
        /// </summary>
        public override string ToString() 
        {
            return $"{RelativePath}{BuildManifestFileInfo.Separator}{AzureArtifactsHash}{SerializeHashes(BuildManifestHashes)}";
        }

        private string SerializeHashes(IReadOnlyList<ContentHash> buildManifestHashes)
        {
            var sb = new StringBuilder();
            foreach (var hash in buildManifestHashes)
            {
                sb.Append(Separator);
                sb.Append(hash.ToString());
            }

            return sb.ToString();
        }

        /// <summary>
        /// Try to parse strings generated by <see cref="ToString"/>
        /// </summary>
        public static bool TryParse(string val, out BuildManifestFileInfo fileInfo)
        {
            fileInfo = null;

            var splits = val.Split(Separator);

            if (splits.Length < MinFieldCount)
            {
                return false;
            }

            var relativePath = splits[0];
            if (string.IsNullOrWhiteSpace(relativePath))
            {
                return false;
            }

            if (!ContentHash.TryParse(splits[1], out var azureArtifactsHash))
            {
                return false;
            }

            var manifestHashes = new List<ContentHash>(splits.Length - 2);
            foreach (var serializedHash in splits.Skip(2))
            {
                if (ContentHash.TryParse(serializedHash, out var hash))
                {
                    manifestHashes.Add(hash);
                }
                else
                {
                    return false;
                }
            }

            fileInfo = new BuildManifestFileInfo(
                relativePath,
                azureArtifactsHash,
                manifestHashes);

            return true;
        }

        /// <nodoc/>
        public bool Equals(BuildManifestFileInfo other)
        {
            return string.Equals(RelativePath, other?.RelativePath) &&
                string.Equals(AzureArtifactsHash, other?.AzureArtifactsHash) &&
                BuildManifestHashes.SequenceEqual(other?.BuildManifestHashes);
        }
    }
}
