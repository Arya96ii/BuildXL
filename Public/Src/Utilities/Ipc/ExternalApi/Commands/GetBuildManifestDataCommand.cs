// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.IO;
using BuildXL.Utilities.Core;
using System.Diagnostics.ContractsLight;
using BuildXL.Cache.ContentStore.Hashing;
using System.Linq;
using System.Text;

namespace BuildXL.Ipc.ExternalApi.Commands
{
    /// <summary>
    /// Command corresponding to the <see cref="Client.GetBuildManifesFileList"/> API operation.
    /// </summary>
    public sealed class GetBuildManifesFileListCommand : Command<GetBuildManifesFileListResult>
    {
        /// <summary>
        /// DropName to identify which drop the Build Manifest is being generated for.
        /// </summary>
        public string DropName { get; }

        /// <summary>
        /// The number of files to include.
        /// </summary>
        public int Count { get; }

        /// <nodoc />
        public GetBuildManifesFileListCommand(string dropName, int count)
        {
            Contract.Assert(count > 0);
            DropName = dropName;
            Count = count;
        }

        /// <inheritdoc />
        public override bool TryParseResult(string result, out GetBuildManifesFileListResult commandResult)
        {
            return GetBuildManifesFileListResult.TryParse(result, out commandResult);
        }

        /// <inheritdoc />
        public override string RenderResult(GetBuildManifesFileListResult commandResult)
        {
            Contract.Requires(commandResult != null);

            return commandResult.Render();
        }

        internal override void InternalSerialize(BinaryWriter writer)
        {
            writer.Write(DropName);
            writer.Write(Count);
        }

        internal static Command InternalDeserialize(BinaryReader reader)
        {
            return new GetBuildManifesFileListCommand(reader.ReadString(),reader.ReadInt32());
        }
    }

    /// <summary>
    /// Stores Hash values and RelativePath of individual files added to drop
    /// </summary>
    public sealed class BuildManifestFileInfo : IEquatable<BuildManifestFileInfo>
    {
        /// <nodoc/>
        public string RelativePath { get; }

        /// <nodoc/>
        public ContentHash AzureArtifactsHash { get; }

        /// <nodoc/>
        public IReadOnlyList<ContentHash> BuildManifestHashes { get; }

        /// <nodoc/>
        public BuildManifestFileInfo(
            string relativePath,
            ContentHash azureArtifactsHash,
            IReadOnlyList<ContentHash> buildManifestHashes)
        {
            Contract.Requires(!string.IsNullOrEmpty(relativePath));
            Contract.Requires(azureArtifactsHash.IsValid);
            Contract.Requires(buildManifestHashes.All(h => h.IsValid));

            RelativePath = relativePath;
            AzureArtifactsHash = azureArtifactsHash;
            BuildManifestHashes = buildManifestHashes;
        }

        /// <summary>
        /// Separator used for serialization
        /// </summary>
        public const char Separator = '|';

        /// <summary>
        /// Number of fields to be serialized within BuildManifestFileInfo
        /// </summary>
        private const int MinFieldCount = 3;

        /// <summary>
        /// String representation format: RelativePath | AzureArtifactsHash | BuildManifestHash
        /// </summary>
        public override string ToString()
        {
            return $"{RelativePath}{BuildManifestFileInfo.Separator}{AzureArtifactsHash}{SerializeHashes(BuildManifestHashes)}";
        }

        private string SerializeHashes(IReadOnlyList<ContentHash> buildManifestHashes)
        {
            var sb = new StringBuilder();
            foreach (var hash in buildManifestHashes)
            {
                sb.Append(Separator);
                sb.Append(hash.ToString());
            }

            return sb.ToString();
        }

        /// <summary>
        /// Try to parse strings generated by <see cref="ToString"/>
        /// </summary>
        public static bool TryParse(string val, out BuildManifestFileInfo fileInfo)
        {
            fileInfo = null;

            var splits = val.Split(Separator);

            if (splits.Length < MinFieldCount)
            {
                return false;
            }

            var relativePath = splits[0];
            if (string.IsNullOrWhiteSpace(relativePath))
            {
                return false;
            }

            if (!ContentHash.TryParse(splits[1], out var azureArtifactsHash))
            {
                return false;
            }

            var manifestHashes = new List<ContentHash>(splits.Length - 2);
            foreach (var serializedHash in splits.Skip(2))
            {
                if (ContentHash.TryParse(serializedHash, out var hash))
                {
                    manifestHashes.Add(hash);
                }
                else
                {
                    return false;
                }
            }

            fileInfo = new BuildManifestFileInfo(
                relativePath,
                azureArtifactsHash,
                manifestHashes);

            return true;
        }

        /// <nodoc/>
        public bool Equals(BuildManifestFileInfo other)
        {
            return string.Equals(RelativePath, other?.RelativePath) &&
                string.Equals(AzureArtifactsHash, other?.AzureArtifactsHash) &&
                BuildManifestHashes.SequenceEqual(other?.BuildManifestHashes);
        }
    }

    /// <summary>
    /// Result of creating a build manifest file list for a drop
    /// </summary>
    public sealed class GetBuildManifesFileListResult
    {
        /// <summary>
        /// List of files added to drop. Returns null if the operation failed.
        /// </summary>
        public List<BuildManifestFileInfo> FileList { get; }

        /// <summary>
        /// Whether there are still data available that were not included due to limits specified in the request.
        /// </summary>
        public bool HasMoreData { get; }

        /// <summary>
        /// The result of the operation
        /// </summary>
        public OperationStatus Status { get; }

        /// <summary>
        /// If the operation failed, describes the error; otherwise null.
        /// </summary>
        public string Error { get; }

        private GetBuildManifesFileListResult(OperationStatus status, List<BuildManifestFileInfo> fileList, string errorMessage, bool hasMoreData)
        {
            FileList = fileList;
            Status = status;
            Error = errorMessage;
            HasMoreData = hasMoreData;
        }

        /// <nodoc />
        public static GetBuildManifesFileListResult CreateForSuccess(List<BuildManifestFileInfo> fileList, bool hasMoreData)
        {
            Contract.Requires(fileList != null);

            return new GetBuildManifesFileListResult(OperationStatus.Success, fileList, null, hasMoreData);
        }

        /// <nodoc />
        public static GetBuildManifesFileListResult CreateForFailure(OperationStatus status, string errorMessage)
        {
            Contract.Requires(!string.IsNullOrEmpty(errorMessage));
            Contract.Requires(status != OperationStatus.Success);

            return new GetBuildManifesFileListResult(status, null, errorMessage, false);
        }

        /// <nodoc />
        public string Render()
        {
            using var stringBuilderPoolInstance = Pools.StringBuilderPool.GetInstance();
            var sb = stringBuilderPoolInstance.Instance;

            sb.AppendLine($"{(byte)Status}");
            if (Status == OperationStatus.Success)
            {
                sb.AppendLine($"{FileList.Count}");
                sb.AppendLine(HasMoreData ? "1" : "0");

                foreach (BuildManifestFileInfo fileInfo in FileList)
                {
                    sb.AppendLine(fileInfo.ToString());
                }
            }
            else
            {
                sb.Append(Error);
            }

            return sb.ToString();
        }

        /// <nodoc />
        public static bool TryParse(string renderedResult, out GetBuildManifesFileListResult result)
        {
            using var reader = new StringReader(renderedResult);
            var statusValue = reader.ReadLine();
            if (!byte.TryParse(statusValue, out var status))
            {
                result = null;
                return false;
            }

            var operationStatus = (OperationStatus)status;
            if (!Enum.IsDefined(typeof(OperationStatus), operationStatus))
            {
                result = null;
                return false;
            }

            if (operationStatus == OperationStatus.Success)
            {
                var fileList = new List<BuildManifestFileInfo>();
                var count = reader.ReadLine();
                if (!int.TryParse(count, out var numberOfFiles))
                {
                    result = null;
                    return false;
                }

                if (!int.TryParse(reader.ReadLine(), out var hasMoreData))
                {
                    result = null;
                    return false;
                }

                for (int i = 0; i < numberOfFiles; i++)
                {
                    string val = reader.ReadLine();
                    if (!BuildManifestFileInfo.TryParse(val, out var buildManifestFileInfo))
                    {
                        result = null;
                        return false;
                    }

                    fileList.Add(buildManifestFileInfo);
                }

                result = CreateForSuccess(fileList, hasMoreData == 1);
            }
            else
            {
                var error = reader.ReadToEnd();
                result = CreateForFailure(operationStatus, error);
            }

            return true;
        }

        /// <nodoc />
        public enum OperationStatus : byte
        {
            /// <nodoc />
            Success,

            /// <nodoc />
            InternalError,

            /// <nodoc />
            UserError
        }
    }
}
